## DEPENDENCIAS UTILIZADAS:

    npm install react react-dom react-router-dom redux react-redux @reduxjs/toolkit bootstrap
    npm install --save-dev @types/react @types/react-dom @types/react-router-dom @types/redux @types/react-redux @types/bootstrap

    -Creación de los primeros componenetes y páginas: NavBar y Home 
    -Creación de la carpeta rutas y definición de las rutas
    -Creación del componente Login

     * Apartir de aqui ya empiezo a contruir el backend ya que Login ya requiere uso del servidor y una base de datos

     -Inicialización de un proyecto de Node dentro de la carpeta backend: 

        1- npm init -y    (cración del package.json para instalar las dependencias)

        2- Instalación de dependencias:
                -express: Para crear tu servidor.
                -cors: Para habilitar CORS, lo que permite que tu frontend se comunique con tu backend.
                -multer: Para manejar la carga de archivos (imágenes).
                -mongoose: Para interactuar con MongoDB.         ->IMPORTANTE: Mongoose, una librería de Node.js que facilita la interacción con MongoDB.<-
                -dotenv: Para manejar variables de entorno.
                -axios para realizar peticiones asincronas al servidor, también se puede utilizar fetch de forma nativa en React

                Dependencias: npm install express cors multer mongoose dotenv axios
        
        3- Configurar TypeScript para Node.js:

            npm install --save-dev typescript @types/node @types/express @types/cors @types/multer
        
        4- Crea un archivo de configuración de TypeScript:

            npx tsc --init   (creará el archivo tsconfig.json)

            Ajusta el archivo tsconfig.json para compilar a JavaScript para Node.js. Asegúrate de establecer "target" a "ES6" y "module" a "commonjs".

        5- Creación del servidor express con las rutas:

            archivos server.ts y routesServer.ts

        6- importante si voy a utilizar el sistema de importación de modulos de javascript ES Modules en el que se usa import definir :

             "type": "module", (en el archivo package.json)

            ya que node.js por defecto utiliza el sistema de modulos commonJs con require        

        7- COMPILACIÓN DEL CÓDIGO TYPESCRIPT A JAVASCRIPT (NODE.JS NECESITA HACER LA CONVERSIÓN YA QUE NO INTERPRETA CODIGO TYPESCRIPT)
        
            Importante la estructura de carpetas y archivos para la configuración 

            Ejecutar  (npx tsc) para convertir el código typescript a javascript se creará automáticamente una carpeta llamada dist

            para que no de errores y la carpeta se cree con el código ya convertido a javascript para que node lo entienda hay que mantener la siguinete estructura:
            
                                server/
                ├── dist/                   # Carpeta que contendrá el código compilado (generado tras la compilación)
                ├── node_modules/           # Carpeta de dependencias de Node.js
                ├── package.json            # Archivo de configuración de npm
                ├── package-lock.json       # Archivo de bloqueo de versiones de npm
                ├── tsconfig.json           # Archivo de configuración de TypeScript
                └── src/                    # Carpeta que contiene el código fuente en TypeScript
                    ├── server.ts           # Archivo principal del servidor
                    └── routerServer.ts     # Archivo de rutas del servidor

            Importante también indicar en el archivo tsconfig.json donde se encuentran los archivos con código .ts para poder encontrarlos y convertirlos :

            
                            {
                "compilerOptions": {
                    "target": "ES2016",                               
                    "module": "ESNext",                               /* Usa ES Modules en lugar de CommonJS */
                    "moduleResolution": "node",                       /* Usa la resolución de módulos de Node.js */
                    "esModuleInterop": true,                          /* Facilita la interoperabilidad entre módulos ES y CommonJS */
                    "forceConsistentCasingInFileNames": true,         /* Asegura que los nombres de archivo sean consistentes en los imports */
                    "strict": true,                                   /* Habilita las opciones de verificación de tipos estrictas */
                    "skipLibCheck": true,                             /* Omite la comprobación de tipos en archivos de definición de biblioteca */
                    "outDir": "./dist",                               /* Especifica la carpeta de salida para los archivos compilados */
                    "rootDir": "./src"                                /* Especifica la carpeta raíz de los archivos fuente (contiene los archivos .ts)*/
                },
                "include": ["src"],                                 /* Incluye la carpeta de código fuente (contiene los archivos .ts)*/
                "exclude": ["node_modules"]                         /* Excluye la carpeta node_modules */
                }   

        8- Arranque del servidor    

            node dist/server.js   (ejecutar en ruta server)

        9- MUY IMPORTANTE todos los archivos del backend que contengan código .ts es decir, carpeta de controllers y models tiene que ir dentro de src que es la ubicación dada en la configuración    

            Una vez avanza el proceso de login para registrar un usuario y tenemos los archivos controller y model del login hace falta una base de datos 

        10- Vamos a usar MongoDB Atlas para la base de datos en la nube y Mongoose como ODM (Object Data Modeling) para interactuar con MongoDB desde tu aplicación de Node.js.

        instalación: npm install mongoose


        11- En este proyecto utilizaré redux-persist para mantener las sesiones iniciadas y datos consistentes como la foto de login y el nombre:

            Instalación de redux-persist:  

            Instalación de tipos para redux-persist: npm install --save-dev @types/redux-persist (en caso de usar typescript)

        *Nota para que carguen las imágenes correctamente definir la ruta adecuada en routesServer.ts: (solo funciona si la carpeta la creamos dentro de dist)
            dist en donde se almacena el código compilado de ts a js para que node.js pueda entenderlo y ejecutarlo
            
            // Configuración de almacenamiento para multer
            const storage = multer.diskStorage({
                destination: path.join(__dirname, '../dist/uploads'), // Guardar imágenes en "uploads"
                filename: (req, file, cb) => {
                    cb(null, `${Date.now()}-${file.originalname}`); // Nombre único para cada archivo
                },
            });    



########PROCESO DE ARRANQUE DEL PROYECTO :########

    1.Arrancar el servidor Express:

        C:\Users\David\Desktop\Proyectos personales con React\beyound_the_pages\server> node dist/server.js


    2. Activar la Compilación Automática con Modo de Vigilancia: compilación de archivos .ts de la carpeta src a .js en la carpeta dist

        npx tsc --watch (dentro de server)

        
    3. Levantar el Servidor de Desarrollo de React: (dentro de la carpeta client en el Frontend)

        C:\Users\David\Desktop\Proyectos personales con React\beyound_the_pages\client> npm run dev



       
## PARA POR DESPLEGAR UN PROYECTO FULLSTACK CON UN SERVIDOR Y UN BACKEND EN VERCEL ##

1.cambiar todas las peticiones que actualmente apuntan a tu servidor local (localhost o 127.0.0.1) en tu frontend y
redirigirlas a la URL de tu servidor que está alojado en Vercel:

    // Antes (cuando estaba en local)
    fetch('http://localhost:5000/api/books')
    .then(response => response.json())
    .then(data => console.log(data));

    // Después (ahora en producción en Vercel)
    fetch('https://your-vercel-app.vercel.app/api/books')
    .then(response => response.json())
    .then(data => console.log(data));

2.Usa Variables de Entorno: Para facilitar la transición entre entornos (desarrollo y producción), puedes usar variables de entorno. 
Así no tendrás que cambiar manualmente las URLs cada vez que pases de un entorno a otro.

    const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000';

    fetch(`${API_URL}/api/books`)
    .then(response => response.json())
    .then(data => console.log(data));

3.Esquema de Comunicación Frontend-Servidor en Vercel

    +--------------------+        HTTP Request         +------------------------+       Database Access      +---------------------+
|  React Frontend    |   --------------------->    |  Express Backend (Vercel)|   --------------------->   |   MongoDB Atlas      |
|  (Vercel)          |                              |  API Endpoints          |                             |  (Cloud)             |
|                    |   <---------------------    |  Serveless Functions     |   <---------------------   |                     |
+--------------------+        HTTP Response         +------------------------+       Query Results         +---------------------+


Flujo de Comunicación:

1-React Frontend (cliente):

    El frontend de React está desplegado en Vercel como un sitio estático.
    El usuario interactúa con la interfaz.
    Cuando el usuario necesita datos (como libros desde Google Books o tu base de datos), se realiza una petición HTTP desde el frontend al backend (Express) también alojado en Vercel.

2-Express Backend (servidor):

    El backend es un servidor Express configurado como servidor sin estado (serverless) en Vercel. Esto significa que cada endpoint es manejado como una función independiente, desplegada y gestionada por Vercel.
    El backend procesa la petición, por ejemplo, buscando libros o accediendo a la base de datos MongoDB Atlas.
    Responde al frontend con los datos necesarios (en JSON, por ejemplo).

3-MongoDB Atlas (base de datos):

    El backend se conecta remotamente a MongoDB Atlas para realizar las consultas necesarias a la base de datos.
    La base de datos responde con los datos, que son enviados de vuelta al frontend a través del servidor Express.



    ## AHORA EL PROYECTO TIENE EL MODO PRODUCCIÓN Y EL MODO DESARROLLO ##

    "scripts": {
  "dev": "vite",                           // Para desarrollo
  "build": "tsc -b && vite build",         // Para construir el frontend y backend para producción
  "start": "vite preview",                 // Para servir la versión de producción
  "preview": "vite preview",               // Para previsualizar la versión de producción localmente
  "lint": "eslint ."
}

-npm run dev: Ejecuta un servidor de desarrollo local con recarga en caliente y herramientas de depuración.

-npm run preview: Será útil cuando desees previsualizar la producción localmente antes de desplegarla.

-npm run build: Construye la aplicación para producción (optimizada, lista para desplegar).

-npm start: Ahora servirá la aplicación en modo de producción. Esto es lo que usarías al desplegar o para simular el entorno de producción.

